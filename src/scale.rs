pub mod discrete;
pub mod linear;
pub mod log;
pub mod temporal;
pub mod mapper;

use crate::error::ChartonError;
use self::linear::LinearScale;
use self::log::LogScale;
use self::discrete::DiscreteScale;
use self::temporal::TemporalScale;

use time::OffsetDateTime;

/// Defines how much a scale's domain should be expanded beyond the data limits.
/// Following ggplot2, expansion consists of a multiplicative factor and an additive constant.
/// Supports asymmetric padding: (lower, upper).
#[derive(Debug, Clone, Copy)]
pub struct Expansion {
    /// Multiplicative factors (lower_mult, upper_mult). 
    /// e.g., (0.05, 0.05) for 5% padding on both sides.
    pub mult: (f64, f64),
    /// Additive constants in data units (lower_add, upper_add).
    pub add: (f64, f64),
}

impl Default for Expansion {
    /// Default ggplot2 expansion for continuous scales is 5% on each side.
    fn default() -> Self {
        Self { 
            mult: (0.05, 0.05), 
            add: (0.0, 0.0) 
        }
    }
}

/// Represents an individual tick mark on an axis.
/// Ticks are generated by scales to guide the rendering of axes and grids.
#[derive(Debug, Clone)]
pub struct Tick {
    /// The value in data space (e.g., 100.0, timestamp, or categorical index).
    pub value: f64,
    /// The human-readable string representation (e.g., "100", "Jan 2026").
    pub label: String,
}

/// Represents the mathematical strategy used to transform data into a normalized [0, 1] range.
#[derive(Clone, Debug, PartialEq)]
pub enum Scale {
    /// Linear mapping: equal data intervals result in equal proportional distances.
    Linear,
    /// Logarithmic mapping: handles data spanning multiple orders of magnitude.
    Log,
    /// Categorical mapping: used for discrete strings or labels.
    Discrete,
    /// Temporal mapping: specifically for dates and times.
    Time,
}

/// A container for input data boundaries (the "Domain").
/// It ensures type safety when initializing different scale types from Polars data.
pub enum ScaleDomain {
    /// For Linear/Log: (min, max)
    Continuous(f64, f64),
    /// For Discrete: List of unique labels in display order
    Categorical(Vec<String>),
    /// For Temporal: (start_time, end_time)
    Temporal(OffsetDateTime, OffsetDateTime),
}

/// The common interface for all scale types.
/// Following ggplot2's design, a Scale is only responsible for mapping 
/// data values to a normalized [0, 1] space. The Coordinate System 
/// later maps this [0, 1] value to actual pixels.
pub trait ScaleTrait {
    /// Transforms a data value into a normalized value between 0.0 and 1.0.
    /// * For continuous scales: (val - expanded_min) / (expanded_max - expanded_min)
    /// * For discrete scales: (index + 0.5) / count (centered in band)
    fn normalize(&self, value: f64) -> f64;

    /// Transforms a categorical string value into a normalized value.
    /// * For discrete scales: Maps the string to its index and then normalizes.
    /// * For continuous scales: Usually returns 0.0 or a default.
    fn normalize_string(&self, value: &str) -> f64;

    /// Returns the expanded domain boundaries (min, max) in data space.
    fn domain(&self) -> (f64, f64);

    /// Returns the maximum value in the internal logical space.
    /// 
    /// This value is used by VisualMappers to determine the interpolation range:
    /// * For Continuous scales: returns 1.0 (representing 100% of the range).
    /// * For Discrete scales: returns (n - 1) as f64 (the last valid index).
    fn logical_max(&self) -> f64;

    /// Generates a list of suggested tick marks for an axis.
    /// * `count`: Suggested number of ticks to generate.
    fn ticks(&self, count: usize) -> Vec<Tick>;
}

/// Factory function to instantiate a Scale.
/// Expansion logic is applied here during construction.
pub fn create_scale(
    scale_type: &Scale,
    domain_data: ScaleDomain,
    expand: Expansion, // Added: control how the domain is padded
) -> Result<Box<dyn ScaleTrait>, ChartonError> {
    match scale_type {
        Scale::Linear => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                // Expansion formula: 
                // lower = min - (range * mult.0 + add.0)
                // upper = max + (range * mult.1 + add.1)
                let range = max - min;
                let lower_padding = range * expand.mult.0 + expand.add.0;
                let upper_padding = range * expand.mult.1 + expand.add.1;
                
                Ok(Box::new(LinearScale::new((min - lower_padding, max + upper_padding))))
            } else {
                Err(ChartonError::Scale("Linear scale requires Continuous domain".into()))
            }
        },
        Scale::Log => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                // To maintain visual symmetry on a logarithmic axis, expansion 
                // must be calculated in log-space.
                let log_min = min.ln();
                let log_max = max.ln();
                let log_range = log_max - log_min;
                
                // Apply multiplicative expansion to the logarithmic range.
                // Note: Additive expansion ('add') is rarely used in log scales 
                // as it doesn't map linearly to visual distance.
                let lower_padding = log_range * expand.mult.0;
                let upper_padding = log_range * expand.mult.1;
                
                // Transform the expanded logarithmic boundaries back to the original data space.
                // This ensures the domain remains strictly positive.
                let expanded_min = (log_min - lower_padding).exp();
                let expanded_max = (log_max + upper_padding).exp();
                
                Ok(Box::new(LogScale::new((expanded_min, expanded_max), 10.0)?))
            } else {
                Err(ChartonError::Scale("Log scale requires Continuous domain".into()))
            }
        },
        Scale::Discrete => {
            if let ScaleDomain::Categorical(categories) = domain_data {
                // Pass the expansion settings to the discrete scale constructor.
                // In ggplot2, the default for discrete is often mult: (0, 0), add: (0.6, 0.6).
                Ok(Box::new(DiscreteScale::new(categories, expand)))
            } else {
                Err(ChartonError::Scale("Discrete scale requires Categorical domain".into()))
            }
        },
        Scale::Time => {
            if let ScaleDomain::Temporal(start, end) = domain_data {
                // 1. Calculate the raw duration between start and end
                let diff = end - start;
                let diff_secs = diff.as_seconds_f64();
                
                // 2. Convert expansion factors to seconds for both ends
                // lower_padding = range * mult.0 + add.0
                // upper_padding = range * mult.1 + add.1
                let lower_padding_secs = diff_secs * expand.mult.0 + expand.add.0;
                let upper_padding_secs = diff_secs * expand.mult.1 + expand.add.1;

                let lower_padding = time::Duration::seconds_f64(lower_padding_secs);
                let upper_padding = time::Duration::seconds_f64(upper_padding_secs);

                // 3. Apply padding to both ends
                // Note: checked_sub/add are safer to prevent datetime out-of-bounds
                let expanded_start = start.checked_sub(lower_padding).unwrap_or(start);
                let expanded_end = end.checked_add(upper_padding).unwrap_or(end);

                Ok(Box::new(TemporalScale::new((expanded_start, expanded_end))))
            } else {
                Err(ChartonError::Scale("Time scale requires Temporal domain".into()))
            }
        }
    }
}