pub mod discrete;
pub mod linear;
pub mod log;
pub mod temporal;

use crate::error::ChartonError;
use self::linear::LinearScale;
use self::log::LogScale;
use self::discrete::DiscreteScale;
use self::temporal::TemporalScale;

use time::OffsetDateTime;

/// Represents an individual tick mark on an axis.
/// Ticks are generated by scales to guide the rendering of axes and grids.
#[derive(Debug, Clone)]
pub struct Tick {
    /// The value in data space (e.g., 100.0, timestamp, or categorical index).
    pub value: f64,
    /// The human-readable string representation (e.g., "100", "Jan 2026").
    pub label: String,
}

/// Represents the mathematical strategy used to transform data into a normalized [0, 1] range.
#[derive(Clone, Debug, PartialEq)]
pub enum Scale {
    /// Linear mapping: equal data intervals result in equal proportional distances.
    Linear,
    /// Logarithmic mapping: handles data spanning multiple orders of magnitude.
    Log,
    /// Categorical mapping: used for discrete strings or labels.
    Discrete,
    /// Temporal mapping: specifically for dates and times.
    Time,
}

/// A container for input data boundaries (the "Domain").
/// It ensures type safety when initializing different scale types from Polars data.
pub enum ScaleDomain {
    /// For Linear/Log: (min, max)
    Continuous(f64, f64),
    /// For Discrete: List of unique labels in display order
    Categorical(Vec<String>),
    /// For Temporal: (start_time, end_time)
    Temporal(OffsetDateTime, OffsetDateTime),
}

/// The common interface for all scale types.
/// Following ggplot2's design, a Scale is only responsible for mapping 
/// data values to a normalized [0, 1] space. The Coordinate System 
/// later maps this [0, 1] value to actual pixels.
pub trait ScaleTrait {
    /// Transforms a data value into a normalized value between 0.0 and 1.0.
    /// * For continuous scales: (val - min) / (max - min)
    /// * For discrete scales: (index + 0.5) / count (centered in band)
    fn normalize(&self, value: f64) -> f64;

    /// Returns the domain boundaries (min, max) in data space.
    fn domain(&self) -> (f64, f64);

    /// Generates a list of suggested tick marks for an axis.
    /// * `count`: Suggested number of ticks to generate.
    fn ticks(&self, count: usize) -> Vec<Tick>;
}

/// Factory function to instantiate a Scale.
/// Note: Range and Padding are no longer here. They are now 
/// the responsibility of the Coordinate System.
pub fn create_scale(
    scale_type: &Scale,
    domain_data: ScaleDomain,
) -> Result<Box<dyn ScaleTrait>, ChartonError> {
    match scale_type {
        Scale::Linear => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                Ok(Box::new(LinearScale::new((min, max))))
            } else {
                Err(ChartonError::Scale("Linear scale requires Continuous domain".into()))
            }
        },
        Scale::Log => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                Ok(Box::new(LogScale::new((min, max), 10.0)?))
            } else {
                Err(ChartonError::Scale("Log scale requires Continuous domain".into()))
            }
        },
        Scale::Discrete => {
            if let ScaleDomain::Categorical(categories) = domain_data {
                Ok(Box::new(DiscreteScale::new(categories)))
            } else {
                Err(ChartonError::Scale("Discrete scale requires Categorical domain".into()))
            }
        },
        Scale::Time => {
            if let ScaleDomain::Temporal(start, end) = domain_data {
                Ok(Box::new(TemporalScale::new((start, end))))
            } else {
                Err(ChartonError::Scale("Time scale requires Temporal domain".into()))
            }
        }
    }
}