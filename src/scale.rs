pub mod discrete;
pub mod linear;
pub mod log;
pub mod temporal;
pub mod mapper;

use crate::error::ChartonError;
use self::linear::LinearScale;
use self::log::LogScale;
use self::discrete::DiscreteScale;
use self::temporal::TemporalScale;

use time::OffsetDateTime;

/// Defines how much a scale's domain should be expanded beyond the data limits.
/// Following ggplot2, expansion consists of a multiplicative factor and an additive constant.
#[derive(Debug, Clone, Copy)]
pub struct Expansion {
    /// Multiplicative factor (e.g., 0.05 for 5% padding on each side).
    pub mult: f64,
    /// Additive constant in data units.
    pub add: f64,
}

impl Default for Expansion {
    /// Default ggplot2 expansion for continuous scales is 5% on each side.
    fn default() -> Self {
        Self { mult: 0.05, add: 0.0 }
    }
}

/// Represents an individual tick mark on an axis.
/// Ticks are generated by scales to guide the rendering of axes and grids.
#[derive(Debug, Clone)]
pub struct Tick {
    /// The value in data space (e.g., 100.0, timestamp, or categorical index).
    pub value: f64,
    /// The human-readable string representation (e.g., "100", "Jan 2026").
    pub label: String,
}

/// Represents the mathematical strategy used to transform data into a normalized [0, 1] range.
#[derive(Clone, Debug, PartialEq)]
pub enum Scale {
    /// Linear mapping: equal data intervals result in equal proportional distances.
    Linear,
    /// Logarithmic mapping: handles data spanning multiple orders of magnitude.
    Log,
    /// Categorical mapping: used for discrete strings or labels.
    Discrete,
    /// Temporal mapping: specifically for dates and times.
    Time,
}

/// A container for input data boundaries (the "Domain").
/// It ensures type safety when initializing different scale types from Polars data.
pub enum ScaleDomain {
    /// For Linear/Log: (min, max)
    Continuous(f64, f64),
    /// For Discrete: List of unique labels in display order
    Categorical(Vec<String>),
    /// For Temporal: (start_time, end_time)
    Temporal(OffsetDateTime, OffsetDateTime),
}

/// The common interface for all scale types.
/// Following ggplot2's design, a Scale is only responsible for mapping 
/// data values to a normalized [0, 1] space. The Coordinate System 
/// later maps this [0, 1] value to actual pixels.
pub trait ScaleTrait {
    /// Transforms a data value into a normalized value between 0.0 and 1.0.
    /// * For continuous scales: (val - expanded_min) / (expanded_max - expanded_min)
    /// * For discrete scales: (index + 0.5) / count (centered in band)
    fn normalize(&self, value: f64) -> f64;

    /// Transforms a categorical string value into a normalized value.
    /// * For discrete scales: Maps the string to its index and then normalizes.
    /// * For continuous scales: Usually returns 0.0 or a default.
    fn normalize_string(&self, value: &str) -> f64;

    /// Returns the expanded domain boundaries (min, max) in data space.
    fn domain(&self) -> (f64, f64);

    /// Returns the maximum logical index or value of the domain.
    /// Used by mappers to determine the range of discrete colors or shapes.
    /// * For continuous scales: typically returns 1.0.
    /// * For discrete scales: returns the count of categories minus one.
    fn domain_max(&self) -> f64;

    /// Generates a list of suggested tick marks for an axis.
    /// * `count`: Suggested number of ticks to generate.
    fn ticks(&self, count: usize) -> Vec<Tick>;
}

/// Factory function to instantiate a Scale.
/// Expansion logic is applied here during construction.
pub fn create_scale(
    scale_type: &Scale,
    domain_data: ScaleDomain,
    expand: Expansion, // Added: control how the domain is padded
) -> Result<Box<dyn ScaleTrait>, ChartonError> {
    match scale_type {
        Scale::Linear => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                // Expansion formula: padding = range * mult + add
                let range = max - min;
                let padding = range * expand.mult + expand.add;
                
                Ok(Box::new(LinearScale::new((min - padding, max + padding))))
            } else {
                Err(ChartonError::Scale("Linear scale requires Continuous domain".into()))
            }
        },
        Scale::Log => {
            if let ScaleDomain::Continuous(min, max) = domain_data {
                // To maintain visual symmetry on a logarithmic axis, expansion 
                // must be calculated in log-space.
                let log_min = min.ln();
                let log_max = max.ln();
                let log_range = log_max - log_min;
                
                // Apply multiplicative expansion to the logarithmic range.
                // Note: Additive expansion ('add') is rarely used in log scales 
                // as it doesn't map linearly to visual distance.
                let padding = log_range * expand.mult;
                
                // Transform the expanded logarithmic boundaries back to the original data space.
                // This ensures the domain remains strictly positive.
                let expanded_min = (log_min - padding).exp();
                let expanded_max = (log_max + padding).exp();
                
                Ok(Box::new(LogScale::new((expanded_min, expanded_max), 10.0)?))
            } else {
                Err(ChartonError::Scale("Log scale requires Continuous domain".into()))
            }
        },
        Scale::Discrete => {
            if let ScaleDomain::Categorical(categories) = domain_data {
                // Pass the expansion settings to the discrete scale constructor.
                // In ggplot2, the default for discrete is often mult: 0, add: 0.6.
                Ok(Box::new(DiscreteScale::new(categories, expand)))
            } else {
                Err(ChartonError::Scale("Discrete scale requires Categorical domain".into()))
            }
        },
        Scale::Time => {
            if let ScaleDomain::Temporal(start, end) = domain_data {
                // 1. Calculate the raw duration between start and end
                let diff = end - start;
                
                // 2. Convert expansion factors to seconds
                // ggplot2: expansion = range * mult + add
                let diff_secs = diff.as_seconds_f64();
                let padding_secs = diff_secs * expand.mult + expand.add;
                let padding = time::Duration::seconds_f64(padding_secs);

                // 3. Apply padding to both ends
                // Note: checked_sub/add are safer to prevent datetime out-of-bounds
                let expanded_start = start.checked_sub(padding).unwrap_or(start);
                let expanded_end = end.checked_add(padding).unwrap_or(end);

                Ok(Box::new(TemporalScale::new((expanded_start, expanded_end))))
            } else {
                Err(ChartonError::Scale("Time scale requires Temporal domain".into()))
            }
        }
    }
}